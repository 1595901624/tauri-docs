---
import type { CollectionEntry } from 'astro:content'
import { convertCollectionToTree } from '@src/utils'
import TreeNode from './TreeNode.astro'
import type { TreeNode as TreeNodeType } from '@src/utils'

interface Props {
  entries: CollectionEntry<'docs'>[]
  // Will be appended to the beginning of a slug
  baseUrl?: string
  // Takes into account full slug
  maxDepth?: number
  startAt?: string
}

let { entries, baseUrl, maxDepth, startAt } = Astro.props

const tree = convertCollectionToTree(entries)

function findStartAt(
  tree: TreeNodeType[],
  startAt?: string,
  currentDepth?: number
): TreeNodeType[] {
  if (!startAt) {
    return tree
  }

  // Find the index of what we're looking for
  const nestedIndex = tree.findIndex(
    (node) =>
      node.slug
        .split('/')
        .slice(0, currentDepth ? currentDepth : 1)
        .join('/') ===
      startAt
        .split('/')
        .slice(0, currentDepth ? currentDepth : 1)
        .join('/')
  )

  if (nestedIndex != -1) {
    // If it's the exact one, return it
    if (tree[nestedIndex].slug === startAt) {
      return tree[nestedIndex].children ?? []
    }

    // Otherwise, start iterating again
    return findStartAt(
      tree[nestedIndex].children ?? [],
      startAt,
      currentDepth ? currentDepth + 1 : 2
    )
  }

  throw Error(`Couldn't find the object at the path '${startAt}'`)
}

const unnestedTree = findStartAt(tree, startAt)
---

<ul>
  {unnestedTree.map((node) => <TreeNode node={node} baseUrl={baseUrl} />)}
</ul>
